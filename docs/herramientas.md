## ¿POR QUÉ ESTAS HERRAMIENTAS?
- **Lenguaje de programación:** El lenguaje que voy a utilizar será [JavaScript](https://www.javascript.com/), el cual puede ser utilizado para programar el back-end gracias al entorno de ejecución [Node.js](https://nodejs.org/es/). He escogido este lenguaje debido a su extensa popularidad en el ámbito laboral, por lo que trabajar con él es una opción muy interesante de cara al futuro, además de las numerosas herramientas con las que el lenguaje cuenta y la comunidad tan extensa que lo desarrolla y que será de gran ayuda a la hora de resolver cualquier duda. 

- **Framework para aplicaciones web:** El framework que he elegido utilizar para trabajar con Node.js ha sido [Sails](https://sailsjs.com). Lo considero una de las mejores opciones de la que dispongo, ya que proporciona una amplia variedad de soporte para cualquier base de datos. Además, es capaz de autogenerar APIs, lo cual será bastante útil en el caso de que lo necesite. Por último, y como motivo de valor que siempre considero en cualquier herramienta que selecciono para su uso, cuenta con un amplio ecosistema en el que apoyarme para entender su funcionamiento y resolver las dudas que puedan surgirme.

- **Framework de testeo:** Para la realización de tests usaré el framework de testeo [Mocha](https://mochajs.org/). Mi decisión se ha basado en varios motivos. El primero de ellos ha sido el hecho de que Mocha sea el framework de testeo más popular y utilizado entre la comunidad de desarrolladores de Node.js, lo cual siempre es una gran señal ya que su correcto funcionamiento y calidad están más que asegurados, además de que de esta manera tengo garantias de que contaré con una extensa comunidad en la que podré apoyarme para instruirme en su uso y resolver cualquier problema que pueda aparecer. El segundo motivo es el hecho de que incluye soporte para cualquier libreria de aserciones. Esto se debe a que Mocha, al contrario que otros frameworks de testeo, no incluye una libreria de aserción integrada en su estructura, lo que a priori parece una desventaja, ya que será requerida más configuración para su puesta a punto, pero en realidad hace que esta herramienta sea mucho más flexible. El último motivo que he tenido en cuenta ha sido el hecho de que, en contraste con otros frameworks de testeo, Mocha permite testear código asíncrono con una sintaxis bastante intuitiva y familiar, lo cual he observado que habia resultado un problema para varios compañeros de clase que utilizaban otros marcos de testeo.

- **Libreria de aserciones:** La libreria de aserciones que utilizaré junto al framework de testeo elegido, [Mocha](https://mochajs.org/), será [Chai](https://www.chaijs.com/). He basado mi decisión principalmente en la observación de lo común que resulta utilizar ambas herramientas juntas, lo que trae como consecuencia que exista numerosa documentación de su uso conjunto, lo cuál valoro enormemente ya que reducirá el tiempo requerido para su aprendizaje enormemente, además de que esté más que comprobado que resulta una de las mejores combinaciones posibles para desarrollar tests unitarios. Otro motivo de peso ha sido la sencillez de esta libreria, que cuenta con tres estilos para implementar tests (assert, expect, should) muy intuitivos que harán el desarrollo algo más simple.

- **Base de datos:** La base de datos que utilizaré para almacenar todos los destinos disponibles, junto a las características, servicios y demás información relevante de cada uno de ellos, será [PostgreSQL](https://www.postgresql.org/), la famosa base de datos relacional de código abierto que cuenta con una extensa comunidad y con la cual ya estoy familiarizado. 

- **Servicio de log:** El servicio de log que emplearé para llevar un rastro del flujo de mi microservicio, el cual será de gran utilidad para encontrar el por qué de cada error que se dé o los pasos que se han dado para llevar a cabo una determinada funcionalidad, será [Winston](https://github.com/winstonjs/winston). El principal motivo de mi elección ha sido el hecho de que se trata actualmente de la solución más popular para el sistema de log de las aplicaciones basadas en Node.js debido a su versatilidad, lo que conlleva la existencia de un gran ecosistema en el que podré comenzar mi aprendizaje sobre su uso de una manera sencilla y detallada.   

- **Herramienta de construcción:** La herramienta de construcción que he elegido para la automatización de tareas repetitivas ha sido [Gulp](https://gulpjs.com/). El principal motivo por el que he elegido esta herramienta frente a su principal competidora, Grunt, ha sido el hecho de que esta última utiliza ficheros de configuración basados en JSON, mientras que Gulp utiliza código JavaScript, el cual es más simple, escueto y me encuentro más familiarizado con él, lo que me ayudará a trabajar con esta herramienta de manera más eficiente y eficaz. Además, Gulp no escribe archivos temporales en el disco duro, al contrario que Grunt, por lo que lleva a cabo menos operaciones para realizar la misma tarea, lo que conlleva un tiempo de ejecución menor.
