## ¿POR QUÉ ESTAS HERRAMIENTAS?
- **Lenguaje de programación:** El lenguaje que voy a utilizar será [JavaScript](https://www.javascript.com/), el cual puede ser utilizado para programar el back-end gracias al entorno de ejecución [Node.js](https://nodejs.org/es/). He escogido este lenguaje debido a su extensa popularidad en el ámbito laboral, por lo que trabajar con él es una opción muy interesante de cara al futuro, además de las numerosas herramientas con las que el lenguaje cuenta y la comunidad tan extensa que lo desarrolla y que será de gran ayuda a la hora de resolver cualquier duda. 

- **Framework para aplicaciones web:** El framework que he elegido utilizar para trabajar con Node.js ha sido [Sails](https://sailsjs.com). Lo considero una de las mejores opciones de la que dispongo, ya que proporciona una amplia variedad de soporte para cualquier base de datos. Además, es capaz de autogenerar APIs, lo cual será bastante útil en el caso de que lo necesite. Por último, y como motivo de valor que siempre considero en cualquier herramienta que selecciono para su uso, cuenta con un amplio ecosistema en el que apoyarme para entender su funcionamiento y resolver las dudas que puedan surgirme.

- **Framework de testeo:** Para la realización de tests usaré el framework de testeo [Mocha](https://mochajs.org/). Mi decisión se ha basado en varios motivos. El primero de ellos ha sido el hecho de que Mocha sea el framework de testeo más popular y utilizado entre la comunidad de desarrolladores de Node.js, lo cual siempre es una gran señal ya que su correcto funcionamiento y calidad están más que asegurados, además de que de esta manera tengo garantias de que contaré con una extensa comunidad en la que podré apoyarme para instruirme en su uso y resolver cualquier problema que pueda aparecer. El segundo motivo es el hecho de que incluye soporte para cualquier libreria de aserciones. Esto se debe a que Mocha, al contrario que otros frameworks de testeo, no incluye una libreria de aserción integrada en su estructura, lo que a priori parece una desventaja, ya que será requerida más configuración para su puesta a punto, pero en realidad hace que esta herramienta sea mucho más flexible. El último motivo que he tenido en cuenta ha sido el hecho de que, en contraste con otros frameworks de testeo, Mocha permite testear código asíncrono con una sintaxis bastante intuitiva y familiar, lo cual he observado que habia resultado un problema para varios compañeros de clase que utilizaban otros marcos de testeo.

- **Libreria de aserciones:** La libreria de aserciones que utilizaré junto al framework de testeo elegido, [Mocha](https://mochajs.org/), será [Chai](https://www.chaijs.com/). He basado mi decisión principalmente en la observación de lo común que resulta utilizar ambas herramientas juntas, lo que trae como consecuencia que exista numerosa documentación de su uso conjunto, lo cuál valoro enormemente ya que reducirá el tiempo requerido para su aprendizaje enormemente, además de que esté más que comprobado que resulta una de las mejores combinaciones posibles para desarrollar tests unitarios. Otro motivo de peso ha sido la sencillez de esta libreria, que cuenta con tres estilos para implementar tests (assert, expect, should) muy intuitivos que harán el desarrollo algo más simple.

- **Base de datos:** La base de datos que utilizaré para almacenar todos los destinos disponibles, junto a las características, servicios y demás información relevante de cada uno de ellos, será [PostgreSQL](https://www.postgresql.org/), la famosa base de datos relacional de código abierto que cuenta con una extensa comunidad y con la cual ya estoy familiarizado. 

- **Servicio de log:** El servicio de log que emplearé para llevar un rastro del flujo de mi microservicio, el cual será de gran utilidad para encontrar el por qué de cada error que se dé o los pasos que se han dado para llevar a cabo una determinada funcionalidad, será [Winston](https://github.com/winstonjs/winston). El principal motivo de mi elección ha sido el hecho de que se trata actualmente de la solución más popular para el sistema de log de las aplicaciones basadas en Node.js debido a su versatilidad, lo que conlleva la existencia de un gran ecosistema en el que podré comenzar mi aprendizaje sobre su uso de una manera sencilla y detallada.

- **Herramienta de construcción:** La herramienta de construcción que he elegido para la automatización de tareas repetitivas ha sido [Gulp](https://gulpjs.com/). El principal motivo por el que he elegido esta herramienta frente a su principal competidora, Grunt, ha sido el hecho de que esta última utiliza ficheros de configuración basados en JSON, mientras que Gulp utiliza código JavaScript, el cual es más simple, escueto y me encuentro más familiarizado con él, lo que me ayudará a trabajar con esta herramienta de manera más eficiente y eficaz. Además, Gulp no escribe archivos temporales en el disco duro, al contrario que Grunt, por lo que lleva a cabo menos operaciones para realizar la misma tarea, lo que conlleva un tiempo de ejecución menor.

- **Gestor de contenedores:** Como ya sabemos, un contenedor es una unidad estandar de software que empaqueta código y todas sus dependencias de modo que la aplicación pueda ejecutarse en cualquier entorno de computación sin fallos, de manera segura y rápida. Todo contenedor se basa en una imagen, que se trata de un paquete ejecutable de software que incluye todo lo necesario para ejecutar una aplicación: código, herramientas del sistema, librerias del sistema y configuraciones. Para gestionar la creación, modificación y portabilidad de estos contenedores existen varios gestores, como Podman o Buildah, pero he elegido sobre todas las demás opciones usar Docker. Esta decisión se debe a su uso prácticamente ubicuo en cualquier entorno de desarrollo, prueba o despliegue de aplicaciones hoy en dia, lo que conlleva que cuente con una gran comunidad que sube una gran cantidad de imágenes útiles a la página oficial y que habrá resuelto la mayoria de errores comunes que me puedo encontrar, además de que habituarme a su uso me será de indudable ayuda en el mundo laboral. Por último, Docker también cuenta con una extensa documentación que me ha sido de gran ayuda a la hora de llevar a cabo su instalación y configuración.

- **Sistema de integración continua:** Como sistema de integración continua primaria he elegido [Travis](https://travis-ci.com/). Se trata de una herramienta muy conocida y utilizada en la realización de proyectos que cuenta con una extensa, clara y detallada documentación. Una de las razones de su éxito es lo fácil e intuitiva que resulta, ya que nos permite conectar nuestro repositorio de GitHub a él de manera directa y, mediante la adición a nuestro repositorio de un sencillo fichero de configuración, ya tendriamos configurado por completo la integración continua que esta herramienta nos ofrece, ejecutando en nuestro caso los tests despues de cada actualización de nuestro repositorio.

  Por otro lado, también soporta una gran cantidad de lenguajes como Node, Ruby, PHP, y un largo etcétera. Por último, una de las ventajas más claras de usar Travis es que el entorno de integración continua esta compuesto de multiples runtimes (Node.js, o versiones de PHP, por ejemplo) o data stores. De este modo, podemos probar nuestras aplicaciones contra distintas configuraciones sin tener que tenerlas instaladas localmente.

  Como sistema de integración continua secundario he elegido [Shippable](https://www.shippable.com/). Me he decantado por él debido a que comparte las ventajas de Travis respecto a la facilidad de su adición a cualquier proyecto, ya que se enlaza de manera directa al repositorio que deseemos y le basta con un pequeño fichero de configuración colocado en nuestro repositorio para funcionar de manera plena. También cuenta con una extensa documentación que me ha servido para conocer y manejar la estructura del fichero de configuración.

  Como ventaja que ambos comparten: pueden ser usados directamente desde la nube, y no es necesario instalarlos en nuestro propio ordenador o en un servidor propio.

- **Sistema serverless:** Como sistema serverless en el que desplegar las funciones serverless que voy a implementar he elegido [Vercel](https://vercel.com). Uno de los motivos de mi elección ha sido el hecho de que Vercel está construido sobre AWS Lambdas, por lo que, al igual que AWS Lambdas, Vercel cuenta con un soporte completo de Node.js, el lenguaje en el que está basado mi proyecto. Del mismo modo, su pipeline de CI, características y optimizaciones giran en torno a Node.js. Dado esto, los despliegues en Vercel son bastante rápidos y están disponibles de manera casi inmediata. También es importante puntualizar que Vercel permite desplegar fácilmente múltiples versiones de nuestra aplicación, permitiéndonos desplegar varias ramas de nuestro repositorio bajo diferentes subdominios. Como último motivo de peso, Vercel cuenta con un cliente bastante útil, que mantiene todo de la manera más simple posible, dándonos la posibilidad de desplegar nuestra función o aplicación mediante el uso de un sólo comando.

  He optado por utilizar otro sistema serverless y desplegar en él una nueva función serverless. En este caso, mi elección ha sido [Netlify](https://netlify.com). He basado mi elección en varios motivos. Uno de ellos ha sido lo amplio de su plan gratuito, el cual incluye muchas herramientas útiles que me servirán en mi proyecto. Otro de ellos ha sido la facilidad y la rapidez con la que soy capaz de desplegar con este sistema, ya que el despliegue continuo de mi repositorio está configurado por defecto, por lo que solo debo actualizar mi repo para que este suceda, y dichos despliegues se llevan a cabo en segundos, lo que es una gran ventaja ya que al no estar familiarizado con su uso llevaré a cabo bastantes durante mi aprendizaje. El último motivo de peso que me ha llevado a su elección es su limpia interfaz y sencilla configuración, ya que al contrario de otros sistemas serverless como Firebase, configurar Netlify a tu gusto resulta bastante sencillo gracias a una interfaz clara y simple que te permite navegar por ella sin problemas y encontrar las secciones que busco en pocos instantes.
